package com.adriandondarza.gestionpedidos.springboot.front;

import com.adriandondarza.gestionpedidos.springboo.GestionPedidosApplication;
import com.adriandondarza.gestionpedidos.springboot.controller.InfoFiscalController;
import com.adriandondarza.gestionpedidos.springboot.dto.InfoFiscalDTO;
import com.adriandondarza.gestionpedidos.springboot.model.*;
import com.adriandondarza.gestionpedidos.springboot.repository.*;
import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.context.ConfigurableApplicationContext;

import java.math.BigDecimal;
import java.time.LocalDateTime;

/**
 * Clase de ejecución y prueba funcional del sistema de Gestión de Pedidos.
 * <p>
 * Esta clase actúa como un cliente de consola que simula un flujo de trabajo real. 
 * Levanta el contexto de Spring en perfil de desarrollo ('dev'), inyecta los beans 
 * necesarios y ejecuta una secuencia completa de persistencia: registro de identidad 
 * fiscal, alta de catálogo y procesamiento de una orden de compra con integridad histórica.
 * </p>
 *
 * @author Adrian Dondarza
 * @version 1.0
 * @since 2026-01-14
 */
public class App {

    /**
     * Punto de entrada de la aplicación de consola.
     * <p>
     * Ejecuta un escenario de prueba que valida la correcta configuración de las 
     * relaciones JPA (OneToOne y ManyToMany con atributos) y la integración con 
     * la base de datos Oracle.
     * </p>
     *
     * @param args Argumentos de configuración externa.
     */
    public static void main(String[] args) {
        // 1. Inicialización del contexto de Spring Boot bajo perfil de desarrollo
        ConfigurableApplicationContext context = new SpringApplicationBuilder(GestionPedidosApplication.class)
                .profiles("dev").run(args);

        // 2. Obtención manual de controladores y repositorios desde el contenedor IoC
        InfoFiscalController infoFiscalCtrl = context.getBean(InfoFiscalController.class);
        ClienteRepository clienteRepo = context.getBean(ClienteRepository.class);
        ArticuloRepository articuloRepo = context.getBean(ArticuloRepository.class);
        CompraRepository compraRepo = context.getBean(CompraRepository.class);
        ArticuloCompraRepository lineaRepo = context.getBean(ArticuloCompraRepository.class);

        // Generación dinámica de NIF para garantizar ejecuciones sin conflictos de Primary Key
        String nifSesion = "NIF-" + (System.currentTimeMillis() % 1000000);

        System.out.println("\n>>> INICIANDO FLUJO DE DATOS PROFESIONAL EN ORACLE <<<");

        try {
            // --- FASE 1: GESTIÓN DE IDENTIDAD Y CASCADA ---
            // Se utiliza el controlador para validar la lógica de negocio de registro simultáneo
            System.out.println("[INFO] Insertando Cliente y su Información Fiscal asociada...");
            InfoFiscalDTO registro = new InfoFiscalDTO(nifSesion, "Polígono Industrial Norte", "925112233", "Adrian Dondarza SL");
            infoFiscalCtrl.registrarInfoFiscal(registro);
            System.out.println("[OK] Cliente e InfoFiscal guardados (NIF: " + nifSesion + ")");

            // --- FASE 2: GESTIÓN DE INVENTARIO ---
            // Persistencia de un nuevo artículo de alto valor en el catálogo
            System.out.println("[INFO] Añadiendo nuevo producto al catálogo...");
            Articulo nuevoArt = new Articulo();
            nuevoArt.setNombre("Tarjeta Gráfica RTX 4080");
            nuevoArt.setDescripcion("Componente de alto rendimiento para gaming y diseño");
            nuevoArt.setPrecioActual(new BigDecimal("1200.00"));
            nuevoArt.setStock(15);
            nuevoArt.setActivo(true);
            nuevoArt = articuloRepo.save(nuevoArt);
            System.out.println("[OK] Artículo persistido (ID: " + nuevoArt.getId() + ")");

            // --- FASE 3: TRANSACCIÓN COMERCIAL Y DETALLE DE COMPRA ---
            // Simulación de un pedido real vinculando cliente y producto con precio congelado
            System.out.println("[INFO] Generando pedido de 3 unidades para el cliente...");
            
            // Localización del sujeto de la transacción
            Cliente cliente = clienteRepo.findById(nifSesion).get();
            
            // Cálculo de magnitudes económicas
            int unidades = 3;
            BigDecimal totalPedido = nuevoArt.getPrecioActual().multiply(new BigDecimal(unidades));

            // Persistencia de la cabecera de la compra
            Compra compra = new Compra();
            compra.setCliente(cliente);
            compra.setFechaRealizada(LocalDateTime.now());
            compra.setEstado(EstadoCompra.PENDIENTE);
            compra.setPrecioTotal(totalPedido);
            compra = compraRepo.save(compra);

            // Persistencia de la línea de detalle (Entidad de asociación ManyToMany)
            ArticuloCompra detalle = new ArticuloCompra();
            detalle.setCompra(compra);
            detalle.setArticulo(nuevoArt);
            detalle.setUnidades(unidades);
            detalle.setPrecioCompra(nuevoArt.getPrecioActual()); // Integridad histórica de precios
            lineaRepo.save(detalle);
            
            System.out.println("[OK] Compra y Detalle registrados. Total Facturado: " + totalPedido + "€");

            // --- SECCIÓN DE PRUEBAS DE INTEGRIDAD (COMENTADAS) ---
            
            /* * FASE DE ELIMINACIÓN:
             * Este bloque queda documentado pero desactivado para proteger los registros 
             * que podrían estar sujetos a restricciones de Triggers en Oracle.
             * * if (!infoFiscalRepository.existsById(nifSesion)) { ... }
             * infoFiscalCtrl.eliminarInfoFiscal(nifSesion);
             */

            /* * VALIDACIÓN DE RESTRICCIONES:
             * Prueba de intento de duplicación de NIF para verificar el control de excepciones.
             * infoFiscalCtrl.registrarInfoFiscal(registro);
             */

            System.out.println("\n>>> PROCESO COMPLETADO CON ÉXITO <<<");

        } catch (Exception e) {
            System.err.println("\n[ERROR] Se ha producido un fallo inesperado en el flujo: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Cierre preventivo del contexto para liberar conexiones al pool de Oracle
            context.close();
        }
    }
}